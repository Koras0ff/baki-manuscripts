<!DOCTYPE html>
<html><head><meta charset='utf-8'><title>Collation</title>
<style>
  body { font-family: sans-serif; padding: 20px; }
  details { margin: 8px 0; border: 1px solid #ccc; padding: 6px; border-radius: 4px; }
  summary { font-weight: bold; cursor: pointer; }
  table { width: 100%; border-collapse: collapse; margin-top: 16px; }
  th, td { border: 1px solid #ccc; padding: 6px; white-space: nowrap; }
  th { background: #f9f9f9; }
  .diff { background: #fffb8f; }
  .majority-word { background: #baffba; padding: 0 2px; border-radius: 2px; }
  .diff-word { background: #fffb8f; padding: 0 2px; border-radius: 2px; }
  .stats { margin-top:4px; font-size: 0.9em; color: #333; }
</style>

<script>
  // BIGRAM‐BASED COSINE‐SIMILARITY YARDIMCI
  function cosineSimilarity(vecA, vecB) {
    let dot = 0, magA = 0, magB = 0;
    for (const [bg, countA] of Object.entries(vecA)) {
      magA += countA * countA;
      const countB = vecB[bg] || 0;
      dot += countA * countB;
    }
    for (const countB of Object.values(vecB)) {
      magB += countB * countB;
    }
    if (magA === 0 || magB === 0) return 0;
    return dot / (Math.sqrt(magA) * Math.sqrt(magB));
  }

  let diffMode  = false;
  let statsMode = false;

  function toggleDiff() {
  diffMode = !diffMode;
  document.getElementById('diff-btn').innerText = diffMode ? 'Hide Differences' : 'Show Differences';

  if (diffMode) {
    // Farkları vurgulama
    applyDiffs();
  } else {
    // Vurgulamaları temizle, raw metni geri yükle
    document.querySelectorAll('tbody tr').forEach(tr => {
      Array.from(tr.children)
        .filter(td => td.style.display !== 'none')
        .forEach(td => {
          td.innerHTML = td.dataset.raw;
        });
    });
  }
}

          
  function toggleStats() {
    statsMode = !statsMode;
    document.getElementById('stats-btn').innerText = statsMode ? 'Hide Statistics' : 'Show Statistics';

    // O AN GÖRÜNÜR OLAN SÜTUNLAR
    const visibleTHs = Array.from(document.querySelectorAll('thead tr th'))
                             .filter(th => th.style.display !== 'none');
    const visibleIdxs = visibleTHs.map(th => Array.from(th.parentNode.children).indexOf(th));

    visibleTHs.forEach((th, idx) => {
      const colIndex = visibleIdxs[idx];
      const statDiv  = th.querySelector('.stats');

      if (!statsMode) {
        statDiv.style.display = 'none';
        return;
      }

      // Sadece görünür sütunların bigramFreq’lerini alarak benzerlik hesaplıyoruz
      const info = columnsDataRaw[colIndex];
      let bestSim  = -1, bestId  = '—';
      let worstSim = +2, worstId = '—';

      visibleIdxs.forEach(j => {
        if (j === colIndex) return;
        const other = columnsDataRaw[j];
        const sim = cosineSimilarity(info.bigramFreq, other.bigramFreq);
        if (sim > bestSim)  { bestSim = sim;   bestId = other.id; }
        if (sim < worstSim) { worstSim = sim; worstId = other.id; }
      });

      // Yeni eklenen istatistikler için kelime dizisini ve frekans sözlüğünü oluşturalım
      const rawText = info.fullText.normalize('NFC');
      const wordsArray = rawText
        .toLowerCase()
        .split(/\s+/)
        .filter(w => w.trim() !== '');

      // Token sayısı zaten info.wordCount içinde var
      const tokenCount = info.wordCount;

      // Type sayısı ve frekans sözlüğü
      const freq = {};
      wordsArray.forEach(w => { freq[w] = (freq[w] || 0) + 1; });
      const typeCount = Object.keys(freq).length;

      // TTR (Type/Token Ratio)
      const TTR = tokenCount ? (typeCount / tokenCount).toFixed(2) : '0.00';

      // Hapax‐Legomena (sadece bir kez geçen kelime)
      const hapaxCount = Object.values(freq).filter(c => c === 1).length;

      // Ortalama kelime uzunluğu
      const totalWordLen = wordsArray.reduce((sum, w) => sum + w.length, 0);
      const avgWordLen = tokenCount ? (totalWordLen / tokenCount).toFixed(2) : '0.00';

      // En sık kullanılan ilk 5 kelime
      const topWords = Object.entries(freq)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([w, c]) => `${w} (${c})`)
        .join(', ');

      // StatDiv içine tüm bilgileri ekleyelim
      statDiv.innerHTML =
        '<div><b>Satır Sayısı:</b> ' + info.lineCount + '</div>' +
        '<div><b>Token (Kelime) Sayısı:</b> ' + tokenCount + '</div>' +
        '<div><b>Type (Benzersiz Kelime) Sayısı:</b> ' + typeCount + '</div>' +
        '<div><b>TTR (Type/Token):</b> ' + TTR + '</div>' +
        '<div><b>Hapax‐Legomena (Tek Geçen Kelimeler):</b> ' + hapaxCount + '</div>' +
        '<div><b>Ortalama Kelime Uzunluğu:</b> ' + avgWordLen + ' karakter</div>' +
        '<div><b>En Sık Kullanılan 5 Kelime:</b> ' + topWords + '</div>' +
        '<div><b>En Çok Benzeyen:</b> ' + bestId + ' (' + (bestSim * 100).toFixed(1) + '%)</div>' +
        '<div><b>En Az Benzeyen:</b> ' + worstId + ' (' + (worstSim * 100).toFixed(1) + '%)</div>';
      statDiv.style.display = 'block';
    });
  }

  function applyDiffs() {
    document.querySelectorAll('tbody tr').forEach(tr => {
      const visible = Array.from(tr.children)
        .filter(td => td.style.display !== 'none')
        .filter(td => td.dataset.raw && td.dataset.raw.trim() !== '---');
      if (visible.length < 2) {
        visible.forEach(td => td.innerHTML = td.dataset.raw);
        return;
      }
      visible.forEach(td => td.innerHTML = td.dataset.raw);
      const counts = {};
      visible.forEach(td => {
        counts[td.dataset.raw] = (counts[td.dataset.raw] || 0) + 1;
      });
      let majorityText = visible[0].dataset.raw, maxc = 0;
      for (let txt in counts) {
        if (counts[txt] > maxc) { maxc = counts[txt]; majorityText = txt; }
      }
      const majWords = majorityText.split(/\s+/);
      const diffPositions = new Set();
      visible.forEach(td => {
        if (td.dataset.raw !== majorityText) {
          const words = td.dataset.raw.split(/\s+/);
          words.forEach((w, i) => { if (majWords[i] !== w) diffPositions.add(i); });
        }
      });
      visible.forEach(td => {
        if (td.dataset.raw === majorityText) {
          td.innerHTML = majWords
            .map((w, i) => diffPositions.has(i) ? `<span class='majority-word'>${w}</span>` : w)
            .join(' ');
        } else {
          const ref = majorityText.normalize('NFC');
          const txt = td.dataset.raw.normalize('NFC');
          td.innerHTML = wordDiff(ref, txt);
        }
      });
    });
  }

  function wordDiff(refText, text) {
    const refNorm = refText.normalize('NFC');
    const txtNorm = text.normalize('NFC');
    const refWords = refNorm.split(/\s+/);
    const words    = txtNorm.split(/\s+/);
    const m = refWords.length, n = words.length;
    const dp = Array(m+1).fill().map(() => Array(n+1).fill(0));
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (refWords[i-1] === words[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; }
        else { dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); }
      }
    }
    let i = m, j = n, matches = [];
    while (i > 0 && j > 0) {
      if (refWords[i-1] === words[j-1]) { matches.push(j-1); i--; j--; }
      else if (dp[i-1][j] >= dp[i][j-1]) { i--; } else { j--; }
    }
    const matchSet = new Set(matches);
    return words.map((w, idx) =>
      matchSet.has(idx) ? w : `<span class='diff-word'>${w}</span>`
    ).join(' ');
  }

  // SAYFA YÜKLENDİĞİNDE HER SÜTUN İÇİN columnsDataRaw OLUŞTURULUR
  let columnsDataRaw = [];
  window.addEventListener('load', () => {
    const ths = Array.from(document.querySelectorAll('thead tr th'));
    const trs = Array.from(document.querySelectorAll('tbody tr'));
    columnsDataRaw = ths.map((th, colIndex) => {
      const id = th.dataset.id || '—';
      const lines = trs
        .map(tr => tr.children[colIndex])
        .filter(td => td)
        .map(td => td.dataset.raw || td.textContent)
        .filter(txt => txt.trim() !== '---');
      const lineCount = lines.length;
      const allText = lines.join(' ');
      const wordCount = allText.trim() === '' ? 0 : allText.trim().split(/\s+/).length;
      function getBigrams(text) {
        const s = text.normalize('NFC').toLowerCase().replace(/\s+/g, ' ');
        const chars = Array.from(s);
        const bigrams = {};
        for (let i = 0; i < chars.length - 1; i++) {
          const bg = chars[i] + chars[i+1];
          if (!bg.match(/[\p{P}\p{S}]/u)) {
            bigrams[bg] = (bigrams[bg] || 0) + 1;
          }
        }
        return bigrams;
      }
      const bigramFreq = getBigrams(allText);
      return { id, lines, fullText: allText, wordCount, lineCount, bigramFreq };
    });
  });

  function resetFilters() {
    document.querySelectorAll(
      '.ms-filter input, .must-filter input, .typ-filter input, .muel-filter input, .frm-filter input'
    ).forEach(chk => chk.checked = true);
    const yearInputs = document.querySelectorAll('#year-min, #year-max');
    if (yearInputs.length === 2) {
      const minYear = +yearInputs[0].min;
      const maxYear = +yearInputs[0].max;
      document.getElementById('year-min').value = minYear;
      document.getElementById('year-max').value = maxYear;
    }
    document.getElementById('word-filter').value = '';
    document.querySelector('input[name="word-mode"][value="exact"]').checked = true;
    diffMode = false;
    document.getElementById('diff-btn').innerText = 'Show Differences';
    document.querySelectorAll('tbody tr').forEach(tr => {
      Array.from(tr.children).forEach(td => td.innerHTML = td.dataset.raw);
    });
    applyFilters();
  }

  function applyFilters() {
    const checkedNushas = Array.from(
      document.querySelectorAll('.ms-filter input:checked')
    ).map(chk => chk.value.trim());
    const minY = +document.getElementById('year-min').value;
    const maxY = +document.getElementById('year-max').value;
    const mustList  = Array.from(
      document.querySelectorAll('.must-filter input:checked')
    ).map(chk => chk.value.trim());
    const typList   = Array.from(
      document.querySelectorAll('.typ-filter input:checked')
    ).map(chk => chk.value.trim());
    const muelList  = Array.from(
      document.querySelectorAll('.muel-filter input:checked')
    ).map(chk => chk.value.trim());
    const formList  = Array.from(
      document.querySelectorAll('.frm-filter input:checked')
    ).map(chk => chk.value.trim());
    const wordFilterRaw   = document.getElementById('word-filter').value.toLowerCase();
    const wordFilterExact = wordFilterRaw.trim();
    const wordMode        = document.querySelector('input[name="word-mode"]:checked')?.value || 'free';
    const table = document.querySelector('table');
    const allHeaderCells = table.querySelectorAll('thead tr th');
    const allRowElements = table.querySelectorAll('tbody tr');
    allHeaderCells.forEach((th, colIndex) => {
      const nushaStr   = (th.dataset.nusha    || '').trim();
      const yearStr    = (th.dataset.year     || '').trim();
      const mustensh   = (th.dataset.mustensih|| '').trim();
      const tur        = (th.dataset.tur      || '').trim();
      const muellif    = (th.dataset.muellif  || '').trim();
      const form       = (th.dataset.form     || '').trim();
      const passNusha = nushaStr === '' || checkedNushas.includes(nushaStr);
      let passYear = true;
      if (yearStr !== '') {
        const yearVal = parseInt(yearStr, 10);
        if (!isNaN(yearVal)) {
          passYear = (yearVal >= minY && yearVal <= maxY);
        }
      }
      const passMust = mustensh === '' || mustList.includes(mustensh);
      const passTur  = tur === '' || typList.includes(tur);
      const passMuel = muellif === '' || muelList.includes(muellif);
      const passForm = form === '' || formList.includes(form);
      // Derkenar filtresi orijinalde sabit “Yok” olduğu için her zaman true:
      const passDerk = true;
      const ok = passNusha && passYear && passMust && passDerk && passTur && passMuel && passForm;
      const displayStyle = ok ? '' : 'none';
      th.style.display = displayStyle;
      allRowElements.forEach(tr => {
        const cell = tr.querySelectorAll('td')[colIndex];
        if (cell) cell.style.display = displayStyle;
      });
    });
    allRowElements.forEach(tr => {
      let rowMatches = false;
      if (wordFilterRaw === '') {
        rowMatches = true;
      } else {
        const visibleCells = Array.from(tr.children).filter(
          td => td.style.display !== 'none'
        );
        for (const td of visibleCells) {
          const cellText = (td.dataset.raw || td.textContent).toLowerCase();
          if (wordMode === 'exact') {
            const escaped = wordFilterExact.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const pattern = new RegExp('\\b' + escaped + '\\b', 'i');
            if (pattern.test(cellText)) { rowMatches = true; break; }
          } else {
            if (cellText.includes(wordFilterRaw)) { rowMatches = true; break; }
          }
        }
      }
      tr.style.display = rowMatches ? '' : 'none';
    });
    if (diffMode) applyDiffs();
  }
</script>
</head>
<body>

<div><button id='diff-btn' onclick='toggleDiff()'>Show Differences</button></div>
<div><button id='stats-btn' onclick='toggleStats()'>Show Statistics</button></div>
<div><button id='reset-btn' onclick='resetFilters()'>Reset Filters</button></div>

<div class='filters'>

<details open><summary>Nüsha Adı</summary><div class='ms-filter'>
<label><input type='checkbox' value='1582 Tarihli İÜ nüshası' checked onchange='applyFilters()'> 1582 Tarihli İÜ nüshası</label> 
</div></details>
<details><summary>Yıl Aralığı</summary>
  <div>
    Milâdî yıl: Başlangıç <input id='year-min' type='number' value='1582' min='1582' max='1582' onchange='applyFilters()'>
         Bitiş   <input id='year-max' type='number' value='1582' min='1582' max='1582' onchange='applyFilters()'>
  </div>
</details>

<details><summary>Müellif</summary><div class='muel-filter'>
<label><input type='checkbox' value='Bâkî' checked onchange='applyFilters()'> Bâkî</label> 
</div></details>
<details><summary>Müstensih</summary><div class='must-filter'>
<label><input type='checkbox' value='?' checked onchange='applyFilters()'> ?</label> 
</div></details>
<details><summary>Tür</summary><div class='typ-filter'>
<label><input type='checkbox' value='kaside' checked onchange='applyFilters()'> kaside</label> 
</div></details>
<details><summary>Form</summary><div class='frm-filter'>
<label><input type='checkbox' value='Yazma' checked onchange='applyFilters()'> Yazma</label> 
</div></details>
<details><summary>Kelime Filtrele</summary>
  <div>
    <label><input type='radio' name='word-mode' value='exact' checked onchange='applyFilters()'> Kelime Arama (tam eşleşme)</label>
    <label><input type='radio' name='word-mode' value='free' onchange='applyFilters()'> Serbest Arama (substring)</label><br>
    <label>Kelime: <input id='word-filter' type='text' oninput='applyFilters()'></label>
  </div>
</details>

</div>
<hr>
<table>
<thead><tr>
<th data-header='17_tiem_1959_kaside_33b-34a_teʿāla 'llāh zehī ṭāḳ-ı bülend-i āsmān āsā ' data-id='990-IU-TY-T2853' data-nusha='1582 Tarihli İÜ nüshası' data-year='1582' data-tarih='990/1582' data-mustensih='?' data-tur='kaside' data-muellif='Bâkî' data-form='Yazma'>
<b>id:</b> 990-IU-TY-T2853_17<br>
<b>Kütüphane Adı:</b> İstanbul Üniversitesi Nadir Eserler Kütüphanesi<br>
<b>Koleksiyon Adı:</b> Türkçe Yazmalar<br>
<b>No:</b> T. 2853<br>
<b>Ülke:</b> Türkiye<br>
<b>Şehir:</b> İstanbul<br>
<b>Tarih:</b> 990/1582<br>
<b>Müstensih:</b> ?<br>
<b>Nüshadaki Şiir Sırası:</b> 17<br>
<b>Sayfa:</b> ?<br>
<div class='stats' style='display:none'></div>
</th>
</tr></thead>
<tbody>
<tr>
<td data-raw="teʿāla 'llāh zehī ṭāḳ-ı bülend-i āsmān āsā">teʿāla 'llāh zehī ṭāḳ-ı bülend-i āsmān āsā</td>
</tr>
<tr>
<td data-raw="hezār aḥsent ey burc-ı felek ḳadr semā sīmā">hezār aḥsent ey burc-ı felek ḳadr semā sīmā</td>
</tr>
<tr>
<td data-raw="ʿaceb beyt-i mu​ṣannaʿdur bulınmaz degme dīvānda">ʿaceb beyt-i mu​ṣannaʿdur bulınmaz degme dīvānda</td>
</tr>
<tr>
<td data-raw="feraḥ baẖş u ṣafā güster neşāṭ engīz ü rūḥ efzā">feraḥ baẖş u ṣafā güster neşāṭ engīz ü rūḥ efzā</td>
</tr>
<tr>
<td data-raw="ṣadef gūşın müzeyyen ḳılmaġiçün der-i lafẓından">ṣadef gūşın müzeyyen ḳılmaġiçün der-i lafẓından</td>
</tr>
<tr>
<td data-raw="kelāmın istimāʿ eyler pes-i dīvārdan deryā">kelāmın istimāʿ eyler pes-i dīvārdan deryā</td>
</tr>
<tr>
<td data-raw="hezārān mürdeye bir demde luṭfuñ tāze cān virdi">hezārān mürdeye bir demde luṭfuñ tāze cān virdi</td>
</tr>
<tr>
<td data-raw="mesīḥā resm ü āyīnin muḥaṣṣal eyledüñ iḥyā">mesīḥā resm ü āyīnin muḥaṣṣal eyledüñ iḥyā</td>
</tr>
<tr>
<td data-raw="cihānda bir ḳurı adı ḳalupdur çeşme-i ẖıżruñ">cihānda bir ḳurı adı ḳalupdur çeşme-i ẖıżruñ</td>
</tr>
<tr>
<td data-raw="sen eylersin bugün āb-ı ḥayāt aḥkāmın​ı icrā">sen eylersin bugün āb-ı ḥayāt aḥkāmın​ı icrā</td>
</tr>
<tr>
<td data-raw="kef-i cūduñ vücūd iḳlīmine bir ṭarḥ-ı nev ṣaldı">kef-i cūduñ vücūd iḳlīmine bir ṭarḥ-ı nev ṣaldı</td>
</tr>
<tr>
<td data-raw="ʿimāret buldı luṭfuñla sarāy-ı kühne-i dünyā">ʿimāret buldı luṭfuñla sarāy-ı kühne-i dünyā</td>
</tr>
<tr>
<td data-raw="sipihrüñ nitekim cām-ı zümürrüd fāmı devr eyler">sipihrüñ nitekim cām-ı zümürrüd fāmı devr eyler</td>
</tr>
<tr>
<td data-raw="olur ʿişret sarāy-ı ẖalḳ tā nüh günbed-i ẖaḍrā">olur ʿişret sarāy-ı ẖalḳ tā nüh günbed-i ẖaḍrā</td>
</tr>
<tr>
<td data-raw="cihānda sāġar-ı ʿişret murāduñ üzre devr itsün">cihānda sāġar-ı ʿişret murāduñ üzre devr itsün</td>
</tr>
<tr>
<td data-raw="göñül ẖōşlıḳların ḳılsun müyesser ḥażret-i mevlā">göñül ẖōşlıḳların ḳılsun müyesser ḥażret-i mevlā</td>
</tr>
<tr>
<td data-raw="nigehdāruñ ẖudāvend-i zemīn ü āsmān olsun">nigehdāruñ ẖudāvend-i zemīn ü āsmān olsun</td>
</tr>
<tr>
<td data-raw="cihān ṭurduḳça ābād olsun ol ṭāḳ-ı felek fersā">cihān ṭurduḳça ābād olsun ol ṭāḳ-ı felek fersā</td>
</tr>
</tbody>
</table>
</body></html>